/*
 * This file was generated by the Gradle 'init' task.
 *
 * This is a general purpose Gradle build.
 * Learn how to create Gradle builds at https://guides.gradle.org/creating-new-gradle-builds/
 */

project.version = "1.0.0"

buildscript {
    repositories { jcenter() }

    dependencies {
        classpath 'com.netflix.nebula:gradle-aggregate-javadocs-plugin:2.2.+'
    }
}

apply plugin: 'nebula-aggregate-javadocs'
apply plugin: "java-library"

allprojects{
    apply plugin: "java"
} 


// task document {
//     dependsOn "aggregateJavadocs"
//     doLast {
//         file("$rootProject.buildDir/docs/javadoc").renameTo(file("docs"))
//     }
// }

task document(type: Javadoc, description: 'Generate javadocs from all child projects as if it was a single project', group: 'Documentation') {
	destinationDir = file("$buildDir/docs/javadoc")
	title = "$project.name $version API"
  options.addBooleanOption('-no-module-directories', true)
	options.author true
	options.links 'http://docs.spring.io/spring/docs/4.3.x/javadoc-api/', 'http://docs.oracle.com/javase/8/docs/api/', 'http://docs.spring.io/spring-ws/docs/2.3.0.RELEASE/api/', 'http://docs.spring.io/spring-security/site/docs/4.0.4.RELEASE/apidocs/', 'https://first.wpi.edu/FRC/roborio/release/docs/java/', 'https://www.revrobotics.com/content/sw/max/sw-docs/java/', 'https://www.kauailabs.com/public_files/navx-mxp/apidocs/java/'
	options.addStringOption 'Xdoclint:none', '-quiet'
    println "Building recursive JavaDoc"

    // source subprojects.collect { proj -> proj.sourceSets.main.allJava }  
	subprojects.each { proj ->
        println 'Adding ' + proj.projectDir + "/src/main/java"
		proj.tasks.withType(Javadoc).each { javadocTask ->
            println 'Found JavaDoc task'
			source += javadocTask.source
			classpath += javadocTask.classpath
			excludes += javadocTask.excludes
			includes += javadocTask.includes
		}
	}

    doLast {
		println "Copying javadoc to docs folder"
		delete "docs"
        file("$rootProject.buildDir/docs/javadoc").renameTo(file("docs"))
    }
}

subprojects.each { subproject ->
  evaluationDependsOn(subproject.path)
}
task mmJar(type: Jar, dependsOn: subprojects.jar) {
  subprojects.each { subproject ->
    from subproject.configurations.archives.artifacts.files.collect {
      zipTree(it)
    }
  }
}

task buildRelease(type: Jar){
  delete file("_release")
  delete file("$rootProject.buildDir/libs")
  dependsOn subprojects.fatJar
  dependsOn subprojects.jar
  dependsOn project(":bundle").buildBundle
  // doLast{
  //   subprojects.each { subproject ->
  //   from subproject.configurations.archives.artifacts.files.collect {
  //       zipTree(it)
  //     }
  //   }
  //   // fileTree("_release/modules").each {
  //   //   from it
  //   // }

  //   // from fileTree("_release/modules").files.collect
  //   println "$rootProject.buildDir/libs/lib5k-"+project.version+".jar"
  //   file("$rootProject.buildDir/libs/lib5k-"+project.version+".jar").renameTo(file("_release/lib5k-"+project.version+"-monolithic.jar"))
  // }
}